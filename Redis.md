# Redis支持的数据类型?
## String
```
格式:set key value
```
## Hash
```
格式:hmset name key1 value1 key2 value2 List
```
## List（列表）
```
格式: lpush name value//在 key 对应 list 的头部添加字符串元素

格式: rpush name value //在 key 对应 list 的尾部添加字符串元素
```
## Set（集合）
```
格式: sadd name value
```
## zset(sorted set：有序集合)
```
格式: zadd name score value
```
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。

# 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
## Redis持久化：
内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。
Redis 提供了两种持久化方式：RDB（默认 快照） 和AOF

## RDB:
功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数

## AOF 
Aof是Append-only file缩写

## 比较
- aof文件比rdb更新频率高，优先使用aof还原数据。
- aof比rdb更安全也更大
- rdb性能比aof好
- 如果两个都配了优先加载AOF

Redis基于RESP通讯协议
# Redis 有哪些架构模式？讲讲各自的特点
## 单机
- 特点：
简单

- 缺点
内存容量有限
处理能力有限
无法高可用。

## 主从复制
Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。

只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。

- 特点
降低master读的压力

- 缺点
没有解决master写压力

## 哨兵（基于主从复制模式）
哨兵是监控 redis 主从服务器，并在主服务器下线时自动进行故障转移
不断检查主从服务器是否正常，出现问题时会主动提醒，当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作

- 特性
保证高可用
监控各个节点
自动故障迁移

- 缺点
主从模式，切换需要时间丢数据
没有解决 master 写的压力

## 集群（最少三主三从 六个节点）
Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。

- 特点：
无中心架构（不存在哪个节点影响性能瓶颈）
数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。
可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。
高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本
-实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。

# 使用过Redis分布式锁么，它是怎么实现的？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放 但是分两步操作不能保证原子性 所以要合并成一个命令操作

使用过Redis做异步队列么，你是怎么用的？有什么缺点？
一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

缺点：
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

能不能生产一次消费多次呢？

使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

# 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
## 缓存穿透
查询的请求在缓存中查不到，落在数据库，大量的时候，倒是系统压力过大

- 如何避免？
对查询结果为空的情况也进行缓存，缓存时间设置短一点
对一定不存在的key进行过滤

## 缓存雪崩
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

- 如何避免？
在缓存失效后控制读数据库写缓存的线程数量。
做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

# Redis的内存淘汰？
既然可以设置Redis最大占用内存大小，那么配置的内存就有用完的时候。那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了吗？

- 实际上Redis定义了几种策略用来处理这种情况：
noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
allkeys-lru：从所有key中使用LRU算法进行淘汰
volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
allkeys-random：从所有key中随机淘汰数据
volatile-random：从设置了过期时间的key中随机淘汰
volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰

当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误

# Jredis & RedisTemplate

Jedis是Redis官方推荐的面向Java的操作Redis的客户端，而RedisTemplate是SpringDataRedis中对JedisApi的高度封装。

